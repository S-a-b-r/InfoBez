# Криптосистема RSA

> Если честно, я ничерта не понял эту хрень, если шо, смотрите в книге 153 страница. А лучше просто смотрите алгоритм в конце билета

По теореме Эйлера для любых взаимно простых целых чисел M и n, где M < n верно:
- M<sup>Fi(n)</sup> = 1 (mod n)

В качестве M берем исходное сообщение, которое необходимо зашифровать. Условие взаимной простоты чисел M и n обеспечим тем, что будем выбирать число n = q * p, где 
- q != p
- q, p - большие простые числа

В качестве одностороннего преобразования используем возведение в степень по модулю простого числа. При некотором значении этой степени **e** будем иметь функцию шифрования E, которая преобразует исходное сообщение M В криптограмму C = D ( M ) = M<sup>e</sup> mod n. Параметр e полагаем общедоступным. По известному значению S при известных *n* и *e* вычислительно сложно найти M.

В качестве потайного хода, соответствующей односторонней функии шифрования M<sup>e</sup> mod n, будем использовать также возведение в степень, но с другим значением степени. Новое значение степени d необходимо выбрать таким, чтобы функция дешифрования
- D(C) = C<sup>d</sup> mod n 

была обратной по отношению к E(M) = M<sup>e</sup> mod n

Отсюда следует, что e*d = 1 mod Fi(n)

## Алгоритм  
1. - Выбор p и q (p!=q) - простые числа
   - n = p*q
   - F<sub>i</sub>(n) = (p-1)*(q-1) При этом p-1 или q-1 должно иметь один большой простой множитель, n > 512бит
2. - Выбирается целое число e, что e < F<sub>i</sub>(n) и НОД(е, F<sub>i</sub>(n)) = 1;  
   - d: e*d = 1 mod F<sub>i</sub>(n)
3. p, q, d - секретный ключ, Числа n и e - открытый ключ
 - Процедура подписывания сообщений M: S(secr message) = M<sup>d(mod n)</sup>;  
4. Процедура проверки M' = S<sup>e</sup> (mod n);  
   Если M = M, то сообщение M признается подписанным пользователем, который предоставил ранее открытый ключ е.

Стойкость криптосистемы RSA основана на сложности разложения модуля на два больших простых множителя.